import { Request, Response } from 'express';
import { OpportunityService } from '../../../domain/opportunity/services/opportunity.service';

export class OpportunityController {
  constructor(private readonly opportunityService: OpportunityService) {}

  async getAll(req: Request, res: Response): Promise<void> {
    try {
      const opportunities = await this.opportunityService.getAllOpportunities();
      res.status(200).json({
        status: 'success',
        data: opportunities,
        meta: {
          count: opportunities.length,
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    } catch (error: any) {
      console.error('Error fetching opportunities:', error);
      res.status(500).json({
        status: 'error',
        message: error.message || 'Failed to fetch opportunities',
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    }
  }

  async getById(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const opportunity = await this.opportunityService.getOpportunityById(id);
      
      if (!opportunity) {
        res.status(404).json({
          status: 'error',
          message: 'Opportunity not found',
          meta: {
            timestamp: new Date().toISOString(),
            endpoint: req.originalUrl,
          },
        });
        return;
      }

      res.status(200).json({
        status: 'success',
        data: opportunity,
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    } catch (error: any) {
      console.error('Error fetching opportunity:', error);
      res.status(500).json({
        status: 'error',
        message: error.message || 'Failed to fetch opportunity',
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    }
  }

  async create(req: Request, res: Response): Promise<void> {
    try {
      // Note: ID is NOT included in the request body - it will be auto-generated by the database
      const opportunityData = req.body;

      // Validate required fields
      if (!opportunityData.opportunityName) {
        res.status(400).json({
          status: 'error',
          message: 'opportunityName is required',
          meta: {
            timestamp: new Date().toISOString(),
            endpoint: req.originalUrl,
          },
        });
        return;
      }

      // Convert date strings to Date objects if provided
      if (opportunityData.expectedStartDate) {
        opportunityData.expectedStartDate = new Date(opportunityData.expectedStartDate);
      }
      if (opportunityData.expectedEndDate) {
        opportunityData.expectedEndDate = new Date(opportunityData.expectedEndDate);
      }

      const opportunity = await this.opportunityService.createOpportunity(opportunityData);

      res.status(201).json({
        status: 'success',
        data: opportunity,
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    } catch (error: any) {
      console.error('Error creating opportunity:', error);
      res.status(500).json({
        status: 'error',
        message: error.message || 'Failed to create opportunity',
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    }
  }

  async update(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;

      // Convert date strings to Date objects if provided
      if (updateData.expectedStartDate) {
        updateData.expectedStartDate = new Date(updateData.expectedStartDate);
      }
      if (updateData.expectedEndDate) {
        updateData.expectedEndDate = new Date(updateData.expectedEndDate);
      }

      const opportunity = await this.opportunityService.updateOpportunity(id, updateData);

      res.status(200).json({
        status: 'success',
        data: opportunity,
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    } catch (error: any) {
      console.error('Error updating opportunity:', error);
      const statusCode = error.message.includes('not found') ? 404 : 500;
      res.status(statusCode).json({
        status: 'error',
        message: error.message || 'Failed to update opportunity',
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    }
  }

  async delete(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      await this.opportunityService.deleteOpportunity(id);

      res.status(204).send();
    } catch (error: any) {
      console.error('Error deleting opportunity:', error);
      const statusCode = error.message.includes('not found') ? 404 : 500;
      res.status(statusCode).json({
        status: 'error',
        message: error.message || 'Failed to delete opportunity',
        meta: {
          timestamp: new Date().toISOString(),
          endpoint: req.originalUrl,
        },
      });
    }
  }
} 