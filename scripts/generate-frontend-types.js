#!/usr/bin/env node

/**
 * Generate Frontend Types from Backend Database Enums
 *
 * This script reads backend database enum files and generates corresponding
 * TypeScript types for the frontend, ensuring a single source of truth.
 */

const fs = require("fs");
const path = require("path");

// Paths
const BACKEND_ENUMS_DIR = path.join(__dirname, "../backend/db/enums");
const FRONTEND_TYPES_DIR = path.join(
	__dirname,
	"../frontend/lib/backend-types"
);
const OUTPUT_FILE = path.join(FRONTEND_TYPES_DIR, "enums.ts");

// Ensure output directory exists
if (!fs.existsSync(FRONTEND_TYPES_DIR)) {
	fs.mkdirSync(FRONTEND_TYPES_DIR, { recursive: true });
}

/**
 * Extract enum values from a backend enum file
 */
function extractEnumValues(filePath) {
	const content = fs.readFileSync(filePath, "utf8");

	// Find the pgEnum declaration
	const enumMatch = content.match(
		/pgEnum\s*\(\s*'[^']*'\s*,\s*\[([\s\S]*?)\]\s*\)/
	);
	if (!enumMatch) {
		console.warn(`No pgEnum found in ${filePath}`);
		return null;
	}

	// Extract values from the array
	const valuesString = enumMatch[1];
	const values = valuesString
		.split(",")
		.map((val) => val.trim())
		.filter((val) => val.length > 0)
		.map((val) => val.replace(/^['"]|['"]$/g, "")); // Remove quotes

	return values;
}

/**
 * Generate TypeScript type from enum values
 */
function generateTypeDefinition(typeName, values) {
	const unionType = values.map((val) => `'${val}'`).join(" | ");
	return `export type ${typeName} = ${unionType};`;
}

/**
 * Generate runtime constants and type guards
 */
function generateRuntimeHelpers(typeName, values, constantName) {
	const valuesArray = values.map((val) => `'${val}'`).join(", ");
	const constant = `export const ${constantName}: readonly ${typeName}[] = [${valuesArray}] as const;`;

	const typeGuardName = `is${typeName}`;
	const typeGuard = `export const ${typeGuardName} = (value: string): value is ${typeName} => 
  ${constantName}.includes(value as ${typeName});`;

	return { constant, typeGuard };
}

/**
 * Convert enum file name to type name
 */
function getTypeNameFromFile(fileName) {
	const baseName = fileName.replace(".enum.ts", "");
	return baseName
		.split("-")
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join("");
}

/**
 * Convert type name to constant name
 */
function getConstantName(typeName) {
	return (
		typeName
			.replace(/([A-Z])/g, "_$1")
			.toUpperCase()
			.slice(1) + "_VALUES"
	);
}

/**
 * Main function
 */
function generateFrontendTypes() {
	console.log("üîÑ Generating frontend types from backend database enums...");

	// Read all enum files
	const enumFiles = fs
		.readdirSync(BACKEND_ENUMS_DIR)
		.filter((file) => file.endsWith(".enum.ts"));

	if (enumFiles.length === 0) {
		console.error("‚ùå No enum files found in backend/db/enums/");
		process.exit(1);
	}

	const typeDefinitions = [];
	const constants = [];
	const typeGuards = [];

	// Process each enum file
	enumFiles.forEach((file) => {
		const filePath = path.join(BACKEND_ENUMS_DIR, file);
		const values = extractEnumValues(filePath);

		if (!values || values.length === 0) {
			console.warn(`‚ö†Ô∏è  No values found in ${file}`);
			return;
		}

		const typeName = getTypeNameFromFile(file);
		const constantName = getConstantName(typeName);

		console.log(
			`‚úÖ Processing ${file} -> ${typeName} (${values.length} values)`
		);

		// Generate type definition
		typeDefinitions.push(generateTypeDefinition(typeName, values));

		// Generate runtime helpers
		const helpers = generateRuntimeHelpers(typeName, values, constantName);
		constants.push(helpers.constant);
		typeGuards.push(helpers.typeGuard);
	});

	// Generate the output file
	const outputContent = `/**
 * üö® GENERATED FILE - DO NOT EDIT MANUALLY üö®
 * 
 * This file is automatically generated from backend database enum definitions.
 * 
 * Source: backend/db/enums/*.enum.ts
 * Generated: ${new Date().toISOString()}
 * 
 * To update these types:
 * 1. Modify the enum values in backend/db/enums/*.enum.ts
 * 2. Run: npm run generate:types (or node scripts/generate-frontend-types.js)
 * 
 * ‚ö†Ô∏è DO NOT EDIT THIS FILE DIRECTLY - Your changes will be overwritten!
 */

// ====================================
// TYPE DEFINITIONS
// ====================================

${typeDefinitions.join("\n\n")}

// ====================================
// RUNTIME CONSTANTS
// ====================================

${constants.join("\n\n")}

// ====================================
// TYPE GUARDS
// ====================================

${typeGuards.join("\n\n")}
`;

	// Write the output file
	fs.writeFileSync(OUTPUT_FILE, outputContent);

	console.log(`‚úÖ Generated frontend types: ${OUTPUT_FILE}`);
	console.log(
		`üìä Summary: ${typeDefinitions.length} types, ${constants.length} constants, ${typeGuards.length} type guards`
	);
}

// Run the script
if (require.main === module) {
	try {
		generateFrontendTypes();
	} catch (error) {
		console.error("‚ùå Error generating frontend types:", error);
		process.exit(1);
	}
}

module.exports = { generateFrontendTypes };
